<html>
<head>
    <style>
        body, body {
            padding: 0;
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
    <script src="/socket.io/socket.io.js"></script>
    <script src="dat.gui.min.js"></script>
</head>
<body>
<script>
'use strict'

// config
const config = {
    cspOnEnemies: false,
    cspOnOtherPlayers: false,
    maxOtherPlayersPrediction: 4,
    cspOnSelf: false
}

const gui = new dat.GUI()
for (let param in config) gui.add(config, param)

const canvas = document.createElement('canvas')
const ctx = canvas.getContext('2d')
document.body.appendChild(canvas)

canvas.width = window.innerWidth
canvas.height = window.innerHeight

ctx.fillStyle = 'lightblue'
ctx.fillRect(0, 0, canvas.width, canvas.height)

let state
let myPlayer

const WORLD_WIDTH = 500
const WORLD_HEIGHT = 500
const speed = 3
const TURN_LENGTH = 20

let turns = []
const inputs = []
let serverStateTs
let clientStateTs
let arrivalErrorMarginMs

function shallowCloneObject (obj) {
    const copy = {}
    for (let key in obj) copy[key] = obj[key]
    return copy
}

function getLastTurn () {
    return turns[turns.length - 1]
}

function predictATurn (previousTurn, myInput, turnIndex) {
    // optimization: since there's no rollback that reuses state in memory,
    // feel free to reuse objects and modify past turns, corrupting them.
    // immutability doesn't matter if there's no reuse.
    const { players, enemies } = previousTurn

    players.forEach(player => {
        if (player.dead) return

        const { keyboard } = player

        // if its own player, apply our inputs to predict their effect
        const itsMe = (player.id === socket.id)
        if (itsMe) {
            for (let key in myInput) keyboard[key] = myInput[key]
        }

        if ((config.cspOnSelf && itsMe) ||
            (config.cspOnOtherPlayers && turnIndex <= config.maxOtherPlayersPrediction)) {
            if (keyboard.left) player.x -= speed
            if (keyboard.right) player.x += speed
            if (keyboard.up) player.y -= speed
            if (keyboard.down) player.y += speed
        }
    })

    // enemy logic
    if (config.cspOnEnemies) {
        enemies.forEach(enemy => {
            enemy.x += enemy.vx
            enemy.y += enemy.vy
            if (enemy.x < 0 || WORLD_WIDTH < enemy.x) enemy.vx *= -1
            if (enemy.y < 0 || WORLD_HEIGHT < enemy.y) enemy.vy *= -1
        })
    }

    // previous turn has been mutated and now contains the next turn
    return previousTurn
}

function nextTurnTs () {
    const turnsSinceThen = turns.length - 1
    return clientStateTs + (turnsSinceThen + 1)*TURN_LENGTH
}

let nextLogicTimeout
function scheduleLogic () {
    clearTimeout(nextLogicTimeout)
    const nTT = nextTurnTs()
    const timeout = nTT - Date.now()
    console.log(`scheduling for next turn ${nTT}\nwhich is in ${timeout} ms`)
    nextLogicTimeout = setTimeout(getPresentState, timeout)
}

function getPresentState () {
    // if still waiting to initialize
    if (getLastTurn() == null || ping === Infinity) return

    // if `serverStateTs` is when the turn's state was generated in the server,
    // then we should have sent the input ideally at time 
    // `(serverStateTs - ping - TURN_LENGTH/2)`, so that it arrives right
    // between the turn's generation and the previous turn's generation
    // (so that if ping varies, it's harder for the input to arrive one
    // turn before or later than intended)

    // wrong, this is assuming LL is small (e.g. 20ms). With a big LL it makes no sense to aim for the midle, since it can be bigger than ping itself.
    // let's make a visualization

    // Therefore we should be (ping + TURN_LENGTH/2) advanced to the server
    

    // the mother of conditions
    // gonna end up making an interactive visualization for this condition at this pace

    let its = 0
    while (nextTurnTs() < Date.now()) {
        its++
        if (its > 100) debugger
        const nextIndex = turns.length
        const previousTurn = getLastTurn()
        const myInput = inputs[nextIndex - 1]
        turns.push(predictATurn(previousTurn, myInput, nextIndex))

        if (inputs.length < turns.length) {
            // A turn has actually been advanced (not resimulating past ones)
            inputs.push(shallowCloneObject(myInput))
            socket.emit('input', myInput)
            console.log('sending input', JSON.stringify(myInput))
        }
    }

    scheduleLogic()

    return getLastTurn()
}

function render () {
    requestAnimationFrame(render)
    const state = getLastTurn()
    if (state == null || socket.id == null) return

    myPlayer = state.players.find(player => {
        return (player.id === socket.id)
    })

    const { players, enemies, coins } = state

    // borrar pantalla
    // ctx.globalAlpha = 0.2
    ctx.fillStyle = 'white'
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    ctx.globalAlpha = 1

    ctx.save()

    // center camera on player
    ctx.translate(
        canvas.width/2 - myPlayer.x,
        canvas.height/2 - myPlayer.y
    )

    // coin render
    coins.forEach(coin => {
        ctx.fillStyle = 'yellow'
        ctx.save()
        ctx.translate(coin.x, coin.y)
        ctx.rotate((Date.now() / 200) % (Math.PI*2))
        ctx.fillRect(-coin.size/2,
                     -coin.size/2,
                     coin.size,
                     coin.size)
        ctx.restore()
    })

    // enemy render
    const sizeFactor = (1-(Date.now() / 500 % 1)) + 1
    enemies.forEach(enemy => {
        ctx.fillStyle = 'red'
        const size = enemy.size * sizeFactor
        ctx.fillRect(
            enemy.x - size/2,
            enemy.y - size/2,
            size,
            size
        )
    })

    // player render
    players.forEach(player => {
        if (player.dead) return
        ctx.fillStyle = (player === myPlayer) ? 'blue' : 'green'
        const size = 20
        ctx.fillRect(player.x - player.size/2,
            player.y - player.size/2,
            player.size,
            player.size)
        ctx.textAlign = 'center'
        ctx.font = '10px Helvetica'
        ctx.fillText(
            player.username,
            player.x,
            player.y + player.size/2 + 13)
    })

    ctx.restore()

    players.sort((a, b) => b.score - a.score)
    players.forEach((player, i) => {
      ctx.fillStyle = (player === myPlayer)? 'blue' : 'green'
      ctx.font = '20px Helvetica'
      ctx.fillText(`${player.username}: ${player.score}`, 30, 40 + i*30)
    })

    // render ping/clock data
    ctx.save()
    ctx.translate(0, canvas.height - 190)
    ctx.fillStyle = '#a0a0a0'
    ctx.textAlign = 'right'
    ctx.fillText(`ping: ${ping}`,
                 canvas.width - 30, 40)
    ctx.fillText(`clockDelta: ${clockDelta}`,
                 canvas.width - 30, 70)
    ctx.fillText(`turnsAhead: ${turns.length - 1}`,
                 canvas.width - 30, 100)
    ctx.fillText(`msAhead: ${serverStateTs - clientStateTs}`,
                 canvas.width - 30, 130)
    ctx.fillText(`arrivalErrorMarginMs: ${arrivalErrorMarginMs}`,
                 canvas.width - 30, 160)
    ctx.restore()
}
requestAnimationFrame(render)

const mapping = {
    a: 'left',
    d: 'right',
    w: 'up',
    s: 'down'
}
document.addEventListener('keydown', function (event) {
    // modify last input in the array
    const keyboard = inputs[inputs.length - 1]
    if (!keyboard) return
    keyboard[mapping[event.key]] = true
})
document.addEventListener('keyup', function (event) {
    // modify last input in the array
    const keyboard = inputs[inputs.length - 1]
    if (!keyboard) return
    keyboard[mapping[event.key]] = false
})

const socket = io()

let pingTs
let ping = Infinity

// difference in ms between server and client clock
let clockDelta = 0
// ping server<->client had when this delta was calculated
// the smaller the ping, the more accurate the delta is
let clockDeltaPing = Infinity

function sendPing () {
    pingTs = Date.now()
    socket.emit('sync-ping')
}

socket.on('connect', function () {
    socket.emit('set-username', prompt('Username?'))
    sendPing()
})

socket.on('state', function (newState) {
    if (ping === Infinity) return
    console.log('got state')

    if (turns.length === 1) {
        // it means the game was initialized, running already
        // yet we got a turn before it was predicted????
        console.log('got turn from the server before it was predicted ðŸ‘Œ')
    }

    serverStateTs = Date.now() - ping
    // calculate time when we should have generated the turn
    arrivalErrorMarginMs = Math.min(Math.max(8, ping/5), TURN_LENGTH/2)
    clientStateTs = serverStateTs
                        - ping
                        - arrivalErrorMarginMs // buffer
    turns = [newState]

    // the new "initial/base truth turn" is one ahead from the one we had
    // previously, so discard the first stored input, which belonged to it
    const prevInput = inputs.shift() || {}

    // in case this is the first turn ever, initialize the array
    // using prevInput just as a "mess-up" precaution
    if (inputs.length === 0) inputs.push(prevInput)

    // resimulate and schedule next logic turn
    getPresentState()
    console.log('end of got state')
})

// socket.io already has 'ping' and 'pong' events
// gotta be careful and not use the same name
socket.on('sync-pong', function (serverPastTs) {
    const now = Date.now()
    ping = (now - pingTs) / 2
    if (ping <= clockDeltaPing) {
        clockDeltaPing = ping
        const serverNowTs = serverPastTs + ping
        clockDelta = serverNowTs - now
    }
    setTimeout(sendPing, 300)
})

</script>
</body>
</html>